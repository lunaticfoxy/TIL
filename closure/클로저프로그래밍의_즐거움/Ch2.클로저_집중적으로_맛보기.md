## 이번장의 내용
- 스칼라: 기본 데이터 타입
- 한데 묶어두기: 컬렉션
- 동작하게 만들기: 함수 호출
- Var는 변수가 아니다
- 로컬, 루프, 블록
- 문제 발생 방지하기: 인용
- 호스트 라이브러리 사용하기
- 예외 상황
- 네임스페이스로 코드 모듈화 하기




## 2.1 스칼라 기본 데이터 타입

### 2.1.1 숫자
- 정수, 소수점, + - 기호, 지수 표현용 e 등으로 구성
- 8진법, 16진법 사용 가능
- 정밀도 자리수 지정 가능
- 기본적으로는 호스트 언어의 숫자 체계 사용

### 2.1.2 정수
- 정수로 변환될 수 있는 형태면 기본적으로 정수로 인식
  - 숫자만 존재
  - +, - 로 시작하며 숫자만 존재
  - 진수 표시 존재
- 자바의 long 기본형으로 처리
  - 사이즈가 너무 크면 자동으로 BigInt 사용
- 10진수, 16진수, 8진수, radix-32, 2진수 등 지원
  - 36진수 까지 지원
```clojure
42
+9
-107
9917786472619488492228198283114910358867343885827028118707676848307166514
127
0x7F        ;; 127
0177        ;; 127
32r3V       ;; 127
2r01111111  ;; 127
```

### 2.1.3 부동 소수
- 저장시 소수부와 유효소수점 수로 구성
```clojure
1.17
+1.22
-2.
366e7
23e-14
10.7e-3
```

### 2.1.4 유리수
- 분자, 분모로 구성된 타입
- 유리수 형태로 입력하더라도 더 단순한 구조 (정수, 부동 소수 등) 으로 변환 가능하다면 자동 변환하여 저장
```clojure
22/7
-7/22
10287/8888
-103/4
```


### 2.1.5 심벌
- 독립적인 객체지만 다른 값을 표현하는 용도
  - C의 포인터, 자바의 레퍼런스 타입처럼 다른 객체를 표현하는것과 유사한 개념
  - 역참조는 필요 없음
- 상황에 따라 한 심벌이 다른 객체를 가르킬 수 있음
- 함수 파라미터, 변수, 자바 클래스 등을 표현하기 위해 사용
```clojure
(def yucky-pi 22/7)

yucky-pi
;;=> 22/7
```

### 2.1.6 키워드
- 독립적인 객체로 스스로 값을 포함하고 있음
  - C의 변수나 자바의 Int, Float 등과 같이 직접 값을 저장하는 타입과 유사한 개념
- 이름 앞에 : 를 붙여 다른 타입과 구분
  - 네이밍 규칙은 자유
```clojure
:chumby
:2
:?
:ThisIsTheNMameOfaKeyword
``` 
- 문자열과 뭐가 다르냐?
  - 얼핏보면 동일해보임
  - 문자열은 매번 생성할때마다 같은 값을 지닌 다른 객체가 생성되는 형태
  - 키워드는 다시 생성하더라도 같은 형태면 항상 같은 객체
```clojure
(def a1 "a")  
(def a2 "a")  ; a1, a2는 서로 다른 주소를 바라보고있음
(def a3 :a)
(def a4 :a)   ; a3, a4는 같은 주소를 바라보고 있음
```


### 2.1.7 문자열
- 큰 따옴표로 구성
- 여러줄에 걸쳐 표현시 줄바꿈 문자 포함
```clojure
"This is a String" => "This is a String"
"This is also a
         String"   => "This is also a\n String"
```

### 2.1.8 문자
- 한 글자를 표현하기 위한 타입
  - 자바의 Character 객체와 매칭
- 앞에 \ 를 입력하여 지정 
- 인코딩 방식 지정 가능
```clojure
\a       ; a
\A       ; A
\u0042   ; 유니코드 B
\\       ; \
\30DE    ; 유니코드 가타가나 문자
```


## 2.2 한데 묶어두기: 컬렉션

### 2.2.1 리스트
- LISP 이라는 단어 자체가 리스트 프로세싱 에서 나온 만큼 매우 중요한 타입
- 소괄호를 사용하여 표현
- 인덱스로 접근 불가
- 어떤 타입의 요소라도 표함 가능
  - 리스트 자체도 표함 가능
- 빈 리스트 != nil
  - 일반적인 리습과 다르므로 조심
- 리스트의 맨 첫번째 요소가 함수나 매크로라면 나머지를 파라미터로 판단하여 자동 연산이 일어남
```clojure
(1 2 3 4)
()
(:fred ethel)
(1 2 (a b c) 4 5)
```

### 2.2.2 벡터
- 리스트와 유사한 특징
- 대괄호를 사용해서 표현
- 인덱스로 접근 가능
```clojure
[1 2 :a :b :c]
```


### 2.2.3 맵
- 키와 값 쌍을 저장
- 중괄호를 사용해서 표현
- 각 쌍 사이에는 , 로 구분
```clojure
{1 "one", 2 "two", 3 "three"}
```


### 2.2.4 셋
- 중복되는 값을 제거하여 저장
- 중괄호 앞에 #을 붙여 저장
```clojure
#{1 2 "three" :four 0x5}
```


## 2.3 동작 수행하기: 함수 호출
- 전치 표기법으로 함수 호출
- 리스트의 맨 앞 요소를 함수 명으로 넣으면 나머지 요소를 파라미터로 인식해서 함수 실행 후 결과 리턴
```clojure
(vector 1 2 3) ; vector 라는 함수의 인자로 1, 2, 3 을 넣는다 => java 라면 vector(1, 2, 3)
```
- 함수 호출뿐만 아니라 모든 연산자는 전치 연산으로 수행
```clojure
(+ 1 2) ; 1 + 2
```

## 2.4 Var는 변수가 아니다
- 클로저에서 def 연산자를 이용하여 심볼을 var 라는 개념의 변수와 유사한 형태로 활용 가능
  - 다만 프로그래머가 직접 값을 입력할때만 활용하는것을 권장
  - 한번 입력된 값은 최대한 변경하지 말것
    - scala, kotlin 의 val 과 유사하게 사용하라는 이야기
- (def 이름 값) 을 통해 생성 가능
  - 값은 생략 가능
```clojure
(def x 42)
(def y)
```


## 2.5 함수

### 2.5.1 익명 함수
- 사실 별도의 익명함수는 존재하지 않음
  - 모든 함수 선언 자체가 익명함수를 만든 뒤 해당 함수를 리턴받는 형태이기 때문
- 다음과 같은 방법으로 활용은 가능
  - 사실은 매번 함수를 만든뒤 바로 호출하는 형태
  - 2.5.2 부분 보고 돌아오면 이해하기 편함
```clojure
; 익명함수 생성 - 주소만 튀어나으므로 사용 어려움
(fn [x y]                        ; 함수 인자 벡터 입력 - [x, y]
  (println "Making a set")       ; 함수 본문 입력 - Making a set 을 출력
  #{x, y})                       ; 함수 리턴값 - x, y 값을 set 자료형으로 리턴
  
; 실제 활용하려면
(
  (fn [x y]
    (println "Making a set") 
    #{x, y})                     ; 함수 정의
  1                              ; 파라미터 x
  2                              ; 파라미터 y
)
;; Making a set                  ; 함수 본문 실행되면서 문자열 출력
;; => #{1,2}                     ; 리턴값
```



### 2.5.2 def와 defn 으로 명명된 함수 생성하기
-  def를 활용하기
  - def는 심벌에 클로저 데이터를 할당하기 위해 사용하는 명령어
  - 따라서 익명함수를 만든뒤, 그 익명함수에 def 를 통해 이름을 지정 가능
  - (def 함수이름 익명함수생성) 형태로 활용
```clojure
; 익명함수를 만든 뒤 make-set 이라는 이름을 지정해줌
(def 
  make-set                         ; 함수 이름 입력 - make-set
  (fn [x y]                        ; 2.5.1에서 설명한 방식으로 익명함수 생성
    (println "Making a set")
    #{x, y})
)
```

- defn 을 활용
  - 위의 방식이 너무 복잡해서 만들어둔 별도의 매크로
  - (defn 함수이름 함수설명 입력파라미터 본문 리턴값) 형태로 활용
```clojure
(defn
  make-set                                             ; 함수 이름
  "Takes two values and makes a set from them."        ; 함수 설명 
  [x y]                                                ; 함수 입력 파라미터들
  (println "Making a set")                             ; 함수 본문
  #{x y}                                               ; 함수 리턴값
)
```

### 2.5.3 인수를 여러개 갖는 함수
- 함수 오버로딩에 관한 내용
  - 인자의 개수가 변할때 적용 가능

#### 기존 모델
- Simple Similarity-based Look-alike System (유사성 기반 모델)
  - 모든 유저 사이의 유사도를 계산하여 비교
    - cosine similarity나 Jaccard similarity 사용
    - 또는 통계적인 기법을 사용하기도 함
  - 가장 간단한 방법
  - 문제점
    - O(kNM) 의 시간 복잡도
      - k: 피쳐 크기
      - N: 사용자 수
      - M: 시드
    - 유사한 걸 찾는것 뿐이니 클릭이나 전환에 대한 요소가 무시될 수 있음
      - 중요한 피쳐 이외의 다른 요소로 유사도가 측정될 수 있음
      - => 이건 그냥 고려해주면 되는거 아닌가…???

- Regression-based Look-alike System
  - 시드 유저(1)와 부정적인 유저(0)를 추출하여 로지스틱 리그레션 모델 학습
  - 이후 모델에 전체 유저를 넣어 추출
    - 부정적인 유저 추출 방법
      - 비 시드 유저 중 샘플링 => 타겟 유저가 포함될 수 있으므로 비효율적
      - 과거 해당 광고주의 광고에 미반응한 사람 추출
  - 해당 광고주의 첫 광고이거나, 시드 유저가 새로 들어온 유저라면 콜드 스타트 문제 발생

- Segment Approximation-based Look-alike System
  - 사용자를 관심 카테고리와 같은 세그먼트로 나누어 시드 사용자가 “공유"하는 최상위 세그먼트를 찾는 형태
  - Turn Inc. 에서 사용한다고 이야기한 조건
    - 시드 집합이 C, 새그먼트 집합이 C` 이라 할때
    - C와 C`의 유사도가 a 이상
      - 두 집단이 유사한가
    - C`의 CTR 혹은 CVR과 C의 CTR, CVR의 차이가 일정 이상
      - C`의 CTR, CVR이 C의 CTR, CVR 보다 너무 낮지 않은가
    - |C` U C| 가 |C| 보다 유의미하게 큰가
      - 확장해서 충분한 모수가 나오는가?
  - 세그먼트의 품질에 따라 성능이 크게 차이
  - 소규모 광고주에게는 비효과적


#### 제안하는 모델
- GRAPH-CONSTRAINT LOOK-ALIKE SYSTEM
  - 유사성 비교 모델과 regression 기반 모델을 조합
- 1단계: Global Graph Construction
  - 유저간 유사도 = (유저1 피쳐벡터)*(가중치 매트릭스)*(유저2 피쳐벡터) / |유저1 피쳐 벡터|*|유저 2 피쳐벡터|
  - 근데 저걸 다 구하는건 어려우니 LSH를 통해 비슷한 사용자를 동일한 클러스터에 배치
  - 한 그룹의 크기를 5 ~ 10 이 되도록 조정
- 2단계: Campaign Specific Modeling
  - 광고별로 특화된 모델링을 수행하는 단계
  - 이때 사용할 피쳐를 선택해야 함
    - 광고별로 중요하게 여기는게 다르므로 고려 필요
  - 본인들은 자기들에 특화된 룰 사용
    - 시드에 대해 j번째 피쳐에 대해 평균값 p_j 를 계산
    - 전체 유저에 대해 j번째 피쳐에 대해 평균값 q_j를 계산
    - p_j가 0.5 이상이면 둘의 차이를 기반으로 중요도 계산
      - p_j가 q_j에 비해 클수록 중요한 피쳐
  - 유저 스코어링 시에 피쳐*중요도 를 계싼해서 합한뒤 sigmoid를 적용하여 스코어로 사용


#### 실제 시스템 동작 과정
1. 전체 유저 그래프 생성
1. 후보 유저 선택
  - 1에서 생긴 해싱 결과 사용
1. 피쳐 중요도 계산 (2와 병렬로 수행 가능)
1. 스코어링 + 유저 추천


#### 결과
- 야후에서 광고후 앱 설치한 비율로 비교
  - 시뮬레이션으로 오프라인 테스트만 진행
- 전반적으로 성능 좋았고, 특히 가장 비중 높은 엔터테인먼트에서 높은 성능을 보여줌
  - 앱 설치 비율 50% 향상
- 현재 야후 광고 서비스에 3000개 이상의 캠페인에 대해 동작중

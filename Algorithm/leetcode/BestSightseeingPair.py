"""
주소: https://leetcode.com/problems/best-sightseeing-pair/

내용
- i번째 위치에서의 경관의 가치를 담은 리스트 A가 주어진다
- 이때 경관 두개를 묶어서 한 쌍을 뽑는데 이 쌍의 가치는 각 경관의 가치의 합 - 거리의 차이 이다
  - 식으로 표현하면 A[i] + A[j] + i - j (j > i 일때)
- 해당 리스트에서 최대 경관의 가치를 구해라

샘플
Input: [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11

풀이방법
- 먼저 당연히 안되겠지만 모든 쌍에 대해서 체크 => 답은 나오지만 당연하게 TLE
  - DP로 속도를 늘릴수 있을것이다
- 한 경관이 다른 위치에서 가지는 가치를 생각
  - 원래 경관이 가지는 가치가 x일때 k만큼 떨어진 곳에서는 x-k이겠지
  - 그렇다면 해당 지역내에서 제일 높은 가치를 지닌 경관을 계속 갱신하면서 나가보자
- 먼저 최대 경관 가치를 지니는 지역을 0 지점으로 설정
  - 이 지점을 기준점 이라 부르자
- 그리고 기준점부터 얼마나 떨어졌는지 계산하는 변수를 설정
  - 이걸 거리 라 부르자
- 이제 index가 1인데부터 끝까지 루프를 탐색하면서 다음을 체크
  - 매 이동시마다 거리를 1 증가시킴
  - 기준점과 현재지점 쌍 점수가 최대 스코어보다 높으면 갱신
  - 현재지점의 가치가 기준점가치-거리 보다 높으면
    - 기준점을 현재지점으로 변경
    - 거리를 0으로 갱신
- 루프를 다 돈뒤 최대 점수에 답이 들어가게됨

적용 가능 분야
- 비슷하게 가치가 변하는 분야는 많음
- 보통은 저 가치 하락을 거리가 아니라 다른거로 정하겠지?
- 그렇다면 그냥 가치하락을 기준으로 정렬한다음 활용가능함
- 하지만 웬만한경우 이렇게 단순한 문제는 잘 없으니 상황을 잘 고려해봐야 함
  - 전처리 단계에서 너무 연산을 많이 잡아먹지 않는가
  - 그 이전에 전역에서 최대값이 필요한가? 지역해로 만족할 수 없는가?

"""
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        maxScore = A[0]
        moved = 0
        start = 0
        
        for i in range(1, len(A)):
            moved += 1
            tempScore = A[start] + A[i] - moved
            if tempScore > maxScore:
                maxScore = tempScore
                
            if A[i] > (A[start] - moved):
                start = i
                moved = 0
            
        return maxScore

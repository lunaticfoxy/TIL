### 기본 용어: 네트워크에서 사용되는 용어와 약어 설명
- 옥텟 (= 바이트)
  - 8비트 묶음
  - 네트워크 용어로 옥텟, 일반적인 컴퓨터 용어로 바이트 라고 부름
  - 이 책에서는 커널 동작을 위주로 다루므로 바이트라고 표현함
- 벡터 = 배열
- L2
  - TCP/IP 링크 계층
  - 이더넷
- L3
  - TCP/IP 네트워크 계층
  - IP
- L4
  - TCP/IP 전솓단 계층
  - UDP/TCP/ICMP
- BH (Bottom Half): 후반부
- IRQ: 인터럽트
- RX: 수신
- TX: 송신



### 공통 코딩 패턴
- 네트워킹 기능은 커널의 일부 기능
  - 다른 커널 요소와 상호작용하기 위해 구현
  - 커널 내 타 컴포넌트에서 사용하는 것과 공통적인 요소를 네트워크 단에서도 사용
    - ex) 데이터 스트럭쳐의 레퍼런스 추적
- 커널 내에서 사용되는 공통적인 코딩 트릭에 대한 정리
- 서브 시스템 (= 커널 컴포넌트)
  - 커널 내에서 중요 기능의 집합
  - 동일한 사람에 의해 관리되고 동시에 변화되는 코드


- #### 메모리 캐시
  - 커널의 메모리 할당과 해제에는 kmalloc, kfree 사용
  - 커널에서는 동일한 스트럭처 타입의 여러 인스턴스가 할당되는 경우가 많음
    - 할당과 해제가 자주 일어날 것으로 예상될때 특별한 메모리 캐시 할당
    - 이렇게 전용 메모리 캐시를 만들어두고 여기에서 할당-반환이 발생됨

  - ##### 소켓 버퍼 디스크립터 (Socket buffer descriptors)
    - sk_buff 버퍼 디스크립터를 할당하는데 많이 사용
    - 가장 할당과 반환이 많이 일어나는 영역
  - ##### 인접 프로토콜 (Neighboring protocol) 매핑
    - L3-L2 간 주소 매핑 정보를 저장하는 데이터 스트럭쳐의 할당에 사용
    - 27장에 상세 내용 기재
  - ##### 라우팅 테이블 (Routing tables)
    - 라우트를 정의하기 위한 2개의 데이터 스트럭쳐를 위한 메모리 캐시

  - 캐시의 관리 함수
    - 캐시는 kmem_cache_create, kmem_cache_destroy 함수를 통해 생성 및 소멸됨
    - 캐시내에서는 kmem_cache_alloc, kmem_cache_free 함수를 통해 할당과 해제가 이루어짐
    
- #### 캐시와 해시 테이블
  - 캐시 조회용 루틴과 일반적인 조회 루틴의 차이점
    - 캐시 조회용 루틴은 캐시에 찾는 값이 없을때 새로운 정보를 추가할지 여부를 파라미터로 결정 가능
    - 일반적인 조회 루틴은 찾는 값이 없을때 무조건 가져와서 추가
  - 캐시는 주로 해시 테이블을 사용하여 개발
    - 해싱 키 충돌시 단방향 or 양방향 리스트를 통해 충돌 처리
    - 충돌을 최소화 하는게 중요
    - 해시 테이블 크기 자체를 늘려서 검색 시간 개선 가능 (34장 참조)
  - 키에 무작위 컴포넌트를 추가하여 해싱하는 경우도 존재
    - 인접 계층에서 사용
    - 테이블에서 강제로 충돌을 일으키는 DoS (Denial of Service) 공격에 의한 손상을 줄여줌 (27장 참조)
    
- #### 참조 카운트
  - 이미 삭제된 데이터 스트럭쳐에 접근시 커널 패닉 발생
  - 커널 패닉의 위험 회피 + 가비지 컬렉션의 효율화를 위해 참조 카운트 사용
    - 데이터 스트럭쳐에 대해 참조가 생길때마다 카운트 추가, 참조가 빠질때마다 카운트 제거
    - 참조 카운트 제어를 위해 사용되는 함수명은 xxx_hlod, xxx_release (or xxx_put) 형태
  - 개발자가 참조 카운트에서 버그를 발생시키는경우
    - 참조 해제시 xxx_release 함수 미사용시
      - 데이터 스트럭처의 해제 영원히 불가
      - 점진적 메모리 소진 발생
    - 참조 사용시 xxx_hold 함수 미사용시
      - 이미 해제된 데이터의 참조를 갖게될 수 있음
      - 다른 사용자의 데이터를 손상시키거나 커널 패닉 발생
  - 참조 카운트가 증가되는 경우
    - 2개의 데이터 스트럭처가 긴밀한 연관성이 있을 경우
      - 이럴경우 하나가 주가 되어 다른쪽의 주소 참조
    - 타이머의 핸들러가 데이터 스트럭처에 접근
      - 타이머 시작시 참조 카운트 증가
      - 타이머 종료시 참조 카운트 감소
      - 타이마가 종료전에 데이터 스트럭처가 해제되는것 방지
    - 성공적인 리스트나 해시테이블 조회 후 반환된 해당 요소에 대한 포인터
      - 조회한 값은 다른데서 사용되는 경우가 대부분
      - 따라서 참조 카운트를 증가시켜 데이터를 확실히 사용 가능한 상태로 유지시킴
      - 해제는 사용자의 몫으로 남겨둠
  - 참조 카운트가 0일 경우 스트럭처의 해제가 가능하지만 꼭 해야 하는것은 아님
  - sysf라는 새로운 파일 시스템이 참조 카운트의 사용을 용이하게 만듬

- #### 가비지 컬렉션
  - 커널 서브시스템 단위로 가비키 컬렉션 존재
    - 대부분의 서브시스템이 가지고 있음
  - ##### 비동기적 가비지 컬렉션
    - 이벤트와 무관
    - 타이머가 주기적으로 데이터 스트럭처 체크후 메모리 삭제
    - 주로 참조카운트를 확인
    - 서브시스템에 따라 해제 조건에 대한 별도 논리와 기능이 포함되기도 함
  - ##### 동기적 가비지 컬렉션
    - 즉각적으로 메모리를 확보해야 하는 경우
    - 좀 더 공격적인 메모리 확보 로직 포함 (33장 참조)

- #### 함소 포인터와 가상 함수 테이블 (VFT)
  - C에서 객체지향의 이점을 얻고 깔끔한 코드 관리를 위해 함수 포인터 사용
  - 데이터 스트럭처 내부에 함수 포인터를 집어넣어 내부 함수 (method) 로 사용 가능
  - 네트워킹 코드에서 함수 포인터를 사용하는 예시
    - 라우팅 서브시스템에서 인입/인출 패킷 처리시 sk_buff 내 함수 포인터를 호출하여 루틴 초기화 (35장 참조)
    - 네트워크 하드웨어에서 패킷 전송 준비 완료시 net_device 내 함수 포인터를 통해 루틴 초기화
    - L3 프로토콜이 패킷 전송을 원할때 함수 포인터 집합 중 하나 사용
      - 함수 포인터가 어디에 연결되어있는지에 따라 다른 동작 (4부 참조)
        - 주소 결정이 필요할경우 L3-to-L2 주소 결정이 일어남
        - 주소 경정이 불필요할 경우 다른 루틴 일어남
  - 기타 사용 예시
    - 디바이스 드라이버는 장치 종류에 무관하게 연속적인 단계가 일어남
      - 이때 네트워크 장치에서 추가적인 작업을 허용하려면 net_device 내 함수포인터 사용
      - 커널의 기본 작업만으로 충분하면 대신 NULL 값 지정
      - ex) register_netvice 함수 내 코드 if(dev->init && dev->init(dev) != 0)
        - 초기화 함수가 있는지, 있다면 초기화를 한 결과값이 NULL 인지 체크를 한 라인으로 할 수 있음
  - 사용시 디버깅단계에선 어떤 함수로 초기화했는지 알기 어려우므로 초기화 과정에 대한 루틴 체크가 필요
    - 함수 포인터가 데이터에 기반을 두고 할당된 경우 루틴 체크가 용이 (ex - 디바이스 드라이버에서의 초기화)
    - 복잡한 논리로 초기화 값이 결정되는 경우 체크가 어려움 (ex - L3-to-L2 주소 매핑)
  - 함수 포인터 그룹이 하나의 세트로 이루어질 경우 가상 함수 테이블 (VFT: Virtual Function Table) 이라 부름
    - 사용처
      - 두 서브시스템 사이의 인터페이스
      - 일반적인 커널 컴포넌트의 노출된 인터페이스
    - VFT의 지나친 사용은 코드의 난독화를 일으킴

- #### goto문
  - 커널에서만은 goto문 사용
  - C에서 명시적인 예외를 제공하지 않아서 사용
  - 커널 프로그램 중 명시적 예외 처리가 필요한 경우에 goto를 사용하여 원치 않는 상황을 회피하거나 특정 이벤트 처리
  - 주로 함수 내에서 다른 종류의 응답 값을 처리하거나 코드 중첩을 뛰어넘기 위해 사용

- #### 벡터 정의
  - 가끔 데이터 스트럭쳐 뒤에 추가적인 코드 블록 포함
    - ex) struct abc { ... char placeholder[0]; }
    - 위 예시에서는 placeholder가 데이터 스트럭쳐의 끝을 가리키는 포인터가 됨 (= 메모리 할당 X)
    - abc를 확장하여 자신이 필요한 정의를 추가하였을 경우 기존 abc의 끝 지점을 체크할 수 있는 방법
  - 위 예시와 유사한 사용법이 몇몇 존재 (19장 참조)
  
- #### 조건부 지시문 (#ifdef와 그 계열)
  - 커널에서 특정 기능이 지원되는지 여부를 체크하는데 주로 사용
  - 사용 예시
    - ##### 데이터 스트럭처 정의에서 특정 필드를 포함하거나 제외시킬 때
      - ex) netfilter 디버깅 기능을 사용하고자 할때만 nf_debug 변수를 struct 내 포함
    - ##### 함수 내에서 특정 부분을 포함시키거나 제외할 때
      - ex) 라우팅 캐시 조회 루틴에서 커널이 "IP: use netfilter MARK value as route key" 기능 지원시에만 if문 내 조건 추가
    - ##### 함수에 대한 정확한 프로토 타입 선택
      - ex) 커널이 정책 라우팅을 지원하지 않는 경우에 해싱테이블 초기화 함수에 __init tag를 추가하기 위해 사용
        - __init 추가시 커널 초기화 시에만 사용되고 이후 메모리 상에서 함수가 버려짐
    - ##### 정확한 정의의 함수를 고를 때
      - ex) 컴파일 옵션에 따라 함수의 루틴이 완전히 바뀌길 원할때
  - 7장에서 조건부 지시문의 사용을 줄이기 위한 매크로 사용에 대해 언급


- #### 조건 검사를 위한 컴파일 타임 최적화
  - true, false 결과 체크를 위해 likely, unlikely 매크로 사용
    - 주로 발생되는 경우 likely(변수)
    - 주로 발생되지 않는 경우 unlikely(변수)
  - gcc에서 최적화 옵션 지원
  
- #### 상호 배제 (Mutual Exclusion)
  - 네트워크에서 락킹은 광범위하게 사용
  - 대체적인 상호 배제 방법
    - 스핀락 (Spin locks)
      - 오직 한번에 하나의 스레드만 획득 가능
      - 다른 스레드는 해당 락이 해제될 때 까지 획득 시도하면서 대기
      - 낭비가 크므로 멀티프로세서 시스템 + 짧은 시간의 락에만 사용
      - 락을 획득한 스레드는 Sleep을 사용해선 안됨
    - 읽기-쓰기 스핀락 (Read-write spin locks)
      - 읽기 전용인지, 읽기/쓰기인지에 따라 다른 동작
      - 읽기 전용으로 접근하는 프로세스만 있을 경우 락이 걸리지 않음
      - 단, 읽기/쓰기 용으로 접근하는 프로세스가 하나라도 있을 경우 해당 프로세스 기준으로 스핀락과 동일한 락 적용
    - RCU (Read Copy Update)
      - 최근 리눅스 커널에 도입된 기능
      - 특수한 상황에 사용
        - 읽기/쓰기 락 요청이 읽기 전용 락에 비해 거의 없을 때
        - 락을 획득한 코드가 자동으로 수행되며 sleep이 없을 때
        - 데이터 스트럭처가 락에 의해 보호받고있을때 포인터로 접근이 필요한 경우
      - 사용 방법
        - Reader, Updater, Reclaimer 의 요소로 구분됨
        - Reader
          - 가장 기본적인 접근
          - 일단 Reader를 할당받아야 Updater와 Reclaimer에 접근 가능
          - 참조 카운터 증가
          - Reader를 통해 데이터의 읽기 가능
        - Updater
          - 데이터에 락을 걸고 값을 수정하기 위한 구조체
          - Reader에서 접근 가능하며 Updater에 접근중인 동안 해당 데이터에 자동으로 락이 걸림
            - 락의 종류는 운영체제가 알아서 결정
          - Read, Copy, Update 연산 수행 가능
        - Reclaimer
          - Updater에서 데이터 삭제시 동작
          - Reader가 없는 경우를 체크하고 확실히 데이터가 사용되지 않음이 체크될 경우에 데이터 삭제
    - 세마포어는 네트워크에서는 거의 사용되지 않음
    
- #### 호스트와 네트워크 순서 변환
  - 빅엔디안 vs 리틀엔디안
    - TCP/IP 스택에서는 빅엔디안 사용
  - 다른 방식을 사용하는 프로세서와의 호환성 문제
    - 프로세서마다 다른 형태로 변환해줘야 함
  - 이를 위해 둘 사이의 변환을 위한 별도 매크로 존재
    - 호출만 하면 알아서 변환해 준다
  - 루틴 종류
    - htons : Host-to-network byte order (short)
    - htonl: Host-to-network_byte order (long)
    - ntohs: Network-to-host byte order (short)
    - ntohl: Network-to-host byte order (long)

- #### 캐시 버그
  - 특정 상황에서 호출되지 않아야 하는 루틴으로 접근했을때 메시지 노출
  - BUG_ON 매크로: 캐시 버그 발생시 에러메시지 출력 및 커널 패닉
  - BUG_TRAP 매크로: 캐시 버그 발생시 경고 메시지 출력

- #### 통계
  - 캐시 조회 성공/실패, 메모리 할당 성공/실패 등의 특정 조건 발생의 통계치를 수집하는 기능

- #### 시간 측정
  - 커널에서 동작 시간은 틱 (tick) 으로 측정
  - 1초에 1 타이머가 동작하며 i386 아키텍쳐에서는 그 사이에 1,000 틱 수행
  - 1 타이머마다 지피스 (jiffies) 라는 이름의 전역 변수를 증가시키고, 이를 통해 부팅 후 흐른 시간 측정 가능

- #### 사용자 공간 도구
  - 네트워크와 관련하여 커널에서 사용할 수 있는 도구
  - lputils: arping, rdisc 등 포함
  - net-tools: ifconfig, route, netstat, arp 등 포함
  - IPROUTES2
    - ip 주소 세팅 가능
    - 라우팅 설정 가능
  - 이외에도 리눅스 네트워크 개발 리스트 카아이브 에서 최신 유틸 정보 확인 가능



### 소스코드 훑어보기
- grep으로 훑어보는건 현재 커널 규모에선 한계가 있음
- cscope 추천
  - 함수나 변수의 선언/호출 부분 탐색 가능
  
- #### 죽은 코드
  - 실제 커널상에서 호출되지 않는 코드
    - 컴파일이 안되는 경우는 운 좋은 경우
    - 대부부은 컴파일까지 되지만 사용되지 않음
  - 실제 커널상에는 죽은 코드가 많으므로 이를 염두에 두고 보는 것이 좋음
    
    
### 기능이 패치로 제공될 때
- 기존 커널에 변경 사항이 적용되지 않는 케이스
  - 코드가 문서의 코딩 스타일을 따르지 않음
  - 비슷한 기능을 하는 프로젝트가 존재하며, 다른 커널 개발자들에게 좋은 평을 받고있음
  - 다른 커널 컴포넌트와 중첩되는 부분이 많음
  - 프로젝트의 규모가 너무 큼
  - 아주 특별한 시나리오에서만 사용됨
  - 전체적인 디자인이 주요 커널 개발자를 만족시키지 못함
- 기능이 겹치더라도 적용되는 경우가 있음
  - ex) 방화벽이 네트워크 스택별로 적용됨
